================================================================================
今後の修正予定
================================================================================

作成日: 2026-02-04
最終更新: 2026-02-04

================================================================================
1. スローイン成功率の改善
================================================================================

【問題の概要】
スローインチェックモードではほぼ100%成功するが、試合モードではほとんど失敗する。

【原因分析】
チェックモードと試合モードの主な違い：

1. キャラクター数
   - チェックモード: 2人（スローワーとレシーバーのみ）
   - 試合モード: 10人（全選手）

2. 実行タイミング
   - チェックモード: 即時実行
   - 試合モード: 3秒間の待機後（throwInDelay = 3.0秒）

3. 他選手の干渉
   - チェックモード: なし
   - 試合モード: フォーメーション移動中に干渉可能

4. 位置制御
   - チェックモード: 固定位置
   - 試合モード: 物理演算で動く可能性あり

【試合モードで失敗する具体的な原因】

A) 3秒間の待機時間中の問題
   - 8人の他選手がフォーメーション位置に移動
   - ディフェンダーがスローワーとレシーバーの間に入る
   - レシーバーが他選手に押されて位置がずれる

B) フォーメーション配置の干渉
   - 関連コード: GameScene.ts:2169-2204
   - 他のオフェンス選手とディフェンス選手が同時に移動
   - パスの軌道上に選手が入る可能性

C) 衝突判定の複雑さ
   - 10人の選手間で衝突判定が発生
   - レシーバーがパスをキャッチする前に位置がずれる

【修正案】

案1: 待機時間中に他選手を固定する
   - THROW_IN_OTHER状態の選手の移動を禁止
   - ThrowInOtherAI.tsで移動を停止させる
   - 優先度: 高

案2: レシーバーの周囲にクリアスペースを確保する
   - フォーメーション配置時にレシーバー周囲を避ける
   - FormationUtils.tsの配置ロジックを修正
   - 優先度: 中

案3: ディフェンダーの配置をレシーバーから離す
   - スローイン時のディフェンスフォーメーションを調整
   - 最低距離を設定（例: 2m以上）
   - 優先度: 中

案4: 待機時間の短縮
   - throwInDelayを3.0秒から1.0秒に短縮
   - または、全選手が配置完了後に即時実行
   - 優先度: 低

案5: パス軌道の最適化
   - レシーバーへの直線経路に障害物がある場合、山なりパスの高さを調整
   - Ball.tsのpassWithArc()を修正
   - 優先度: 低

【関連ファイル】
- src/character-move/scenes/GameScene.ts (lines 2114-2228, 956-1028)
- src/character-move/controllers/check/ThrowInCheckController.ts (lines 343-376)
- src/character-move/entities/Ball.ts (lines 967-1159)
- src/character-move/controllers/CollisionHandler.ts (lines 78-168)
- src/character-move/ai/state/ThrowInOtherAI.ts
- src/character-move/config/FormationConfig.ts

【ステータス】
未着手

================================================================================
2. パス軌道計算の改善（移動中のパサー/レシーバー対応）
================================================================================

【問題の概要】
パスチェックモードで確認したところ、パサーもしくはレシーバーが移動してからパスを
行う場合、両者を結ぶ直線計算や放物線計算が正確に行われていない。
シュート軌道は移動中でも正確に計算されているため、同様のシステムを導入したい。

【原因分析】

■ シュート軌道が正確な理由（参考実装）
  ShootTrajectoryVisualizer.ts は「ステートレス設計」を採用：

  ```typescript
  update() {
    this.clearVisualizations();              // 1. 前回の可視化を完全クリア
    const shooterPos = holder.getPosition(); // 2. 現在位置を取得（常に最新）
    // 3. 現在位置から軌道を再計算
    // 4. 新しい可視化を作成
  }
  ```

  特徴:
  - 毎フレーム位置を取得し直す
  - 過去の状態を保持しない
  - ターゲット（ゴール）は固定位置

■ パス軌道が失敗する理由
  PassTrajectoryVisualizer.ts は位置を一度取得して使い回す設計：

  ```typescript
  update(getOffBallAITargetPosition) {
    const passerPos = holder.getPosition();  // ← 一度だけ取得
    // 全チームメイトに対してこの位置を使い回す
    // パサーが移動しても古い位置から計算される
  }
  ```

  問題点:
  - パサーの位置: 移動中に古い位置を使用
  - レシーバーの位置: AIの予測位置を使用（別タイミングで更新）
  - 二つの移動体を追跡する複雑さ（二重移動問題）

■ 比較表

  | 項目           | シュート軌道              | パス軌道                    |
  |----------------|--------------------------|----------------------------|
  | 設計           | ステートレス（毎フレーム再計算）| ステートフル（予測ベース）    |
  | 位置取得       | 毎フレーム最新位置         | フレーム開始時に一度         |
  | ターゲット     | 固定（ゴール）             | 移動中（レシーバー予測位置） |
  | 移動対応       | ✓ 自動追従               | ✗ ずれが発生               |

【修正案】

案1: パス軌道をシュート軌道と同じステートレス設計に変更
   - PassTrajectoryVisualizer.tsを修正
   - 毎フレーム、パサーとレシーバーの現在位置から再計算
   - 優先度: 高

案2: パス実行時（Ball.passWithArc）でも現在位置を使用
   - Ball.ts の passWithArc() メソッドを修正
   - パス実行時点でのパサー/レシーバー位置を正確に取得
   - 優先度: 高

案3: レシーバーの将来位置予測を改善
   - レシーバーの速度ベクトルを考慮
   - ボール飛行時間を計算し、到達時点のレシーバー位置を予測
   - 優先度: 中

案4: 可視化と実行の同期
   - PassTrajectoryVisualizer と Ball.passWithArc() で同じ計算ロジックを使用
   - 表示と実際の動作が一致するようにする
   - 優先度: 中

【関連ファイル】
- src/character-move/visualization/PassTrajectoryVisualizer.ts（パス軌道可視化）
- src/character-move/visualization/ShootTrajectoryVisualizer.ts（参考: シュート軌道可視化）
- src/character-move/entities/Ball.ts - passWithArc()（パス実行）
- src/character-move/controllers/check/PassCheckController.ts - executePass()
- src/character-move/utils/DeterministicTrajectory.ts（軌道計算）

【参考: シュート軌道の実装箇所】
- ShootTrajectoryVisualizer.ts: update() メソッド（98-162行）
- Ball.ts: shootWithArcHeight() メソッド（700-819行）

【ステータス】
未着手

================================================================================
